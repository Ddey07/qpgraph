##
## DEPRECATED FUNCTIONS
##

## function: qpRndHMGM
## deprecation BioC release: 2.12
## purpose: builds a random homogeneous mixed graphical Markov model
##          and for every vertex its boundary <= d
## parameters: nDiscrete - number of discrete variables
##             nContinuous - number of continuous variables
##             d - degree of every vertex
##             mixedIntStrength - strength of the mixed interactions
##             rho - marginal correlation of the quadratic interactions
##             G - input graph, if given
## return: a list with the HMGM

qpRndHMGM <- function(nDiscrete=1, nContinuous=3, d=2, mixedIntStrength=5, rho=0.5, G=NULL) {

  .Deprecated("rHMgmm")

  if (is.null(G)) {
    Delta <- paste("D", 1:nDiscrete, sep="")
    Gamma <- paste("C", 1:nContinuous, sep="")
    V <- c(Delta, Gamma)
    G <- qpRndGraph(p=length(V), d=d, exclude=seq(along=Delta))
    rownames(G) <- colnames(G) <- V
  } else {
    Delta <- colnames(G)[1:nDiscrete]
    Gamma <- colnames(G)[(nDiscrete+1):(nDiscrete+nContinuous)]
  }
  discreteLevels <- rep(2, nDiscrete)
  nDiscreteLevels <- prod(discreteLevels)

  ## p(i)
  pDelta <- rep(1/prod(discreteLevels), times=nDiscreteLevels)

  ## Sigma
  Sigma <- qpG2Sigma(G[Gamma, Gamma, drop=FALSE], rho=rho)
  rownames(Sigma) <- colnames(Sigma) <- Gamma

  ## h(i)
  h <- matrix(0, nrow=nContinuous, ncol=nDiscreteLevels)
  rownames(h) <- Gamma
  colnames(h) <- 1:nDiscreteLevels
  ## edL <- apply(matrix(as.matrix(G[Delta, Gamma]), nrow=length(Delta),
  ##                    ncol=length(Gamma), dimnames=list(Delta, Gamma)),
  ##             2, which)
  edL <- apply(G[Delta, Gamma, drop=FALSE], 2, which)
  edL <- edL[which(sapply(edL, length) > 0)]

  if (length(edL) > 0) {
    levelsDelta <- do.call("expand.grid", rep(list(1:2), nDiscrete))
    colnames(levelsDelta) <- Delta

    h[names(edL), ] <- 
      t(sapply(edL,
               function(whichDiscreteVars, levelsDelta) {
                 if (length(whichDiscreteVars) > 1) {
                   whichLevelsDiffer <- lapply(lapply(split(levelsDelta[, whichDiscreteVars],
                                                            levelsDelta[, whichDiscreteVars]),
                                                      rownames),
                                               as.integer)
                 } else {
                   whichLevelsDiffer <- split(1:nDiscreteLevels, levelsDelta[, whichDiscreteVars])
                 }
                 x <- rep(rnorm(length(whichLevelsDiffer), sd=mixedIntStrength),
                          times=sapply(whichLevelsDiffer, length))
                 x[sort(unlist(whichLevelsDiffer, use.names=FALSE), index.return=TRUE)$ix]
               }, levelsDelta))
  }

  ## mu
  mu <- Sigma %*% h

  list(Delta=Delta, Gamma=Gamma, G=G, dLevels=discreteLevels, h=h, p_i=pDelta,
       Sigma=Sigma, mean_i=mu)
}


## function: qpSampleFromHMGM
## deprecation BioC release: 2.12
## purpose: samples synthetic data from a homogeneous mixed graphical Markov model
## parameters: n - number of observations
##             hmgm - model as generated by the function qpRndHMGM()
## return: the sampled synthetic data

qpSampleFromHMGM <- function(n=10, hmgm=qpRndHMGM()) {

  .Deprecated("rcmvnorm")

  nDiscreteLevels <- prod(hmgm$dLevels)
  nDiscrete <- length(hmgm$Delta)
  nContinuous <- length(hmgm$Gamma)
  levelsDelta <- do.call("expand.grid", rep(list(1:2), nDiscrete))
  colnames(levelsDelta) <- hmgm$Delta

  sampleData <- matrix(0, nrow = n, ncol = (nDiscrete + nContinuous),
                       dimnames = list((1:n), c(hmgm$Delta, hmgm$Gamma)))
  discreteValues <- sample(1:nDiscreteLevels, size=n, prob=hmgm$p_i, replace=TRUE)
  whatLevels <- split(1:n, discreteValues)

  continuousObs <- do.call("rbind",
                           lapply(as.list(names(whatLevels)),
                                  function(x) mvtnorm::rmvnorm(length(whatLevels[[x]]),
                                                               mean=hmgm$mean_i[, as.integer(x)],
                                                               sigma=as.matrix(hmgm$Sigma))))

  sampleData[, hmgm$Delta] <- as.matrix(levelsDelta[discreteValues, ])
  sampleData[unlist(whatLevels, use.names=FALSE), hmgm$Gamma] <- continuousObs

  sampleData
}
